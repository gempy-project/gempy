
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>theanograf &#8212; GemPy beta documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for theanograf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This file is part of gempy.</span>

<span class="sd">    gempy is free software: you can redistribute it and/or modify</span>
<span class="sd">    it under the terms of the GNU General Public License as published by</span>
<span class="sd">    the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">    (at your option) any later version.</span>

<span class="sd">    gempy is distributed in the hope that it will be useful,</span>
<span class="sd">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">    GNU General Public License for more details.</span>

<span class="sd">    You should have received a copy of the GNU General Public License</span>
<span class="sd">    along with gempy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>


<span class="sd">DEP-- I need to update this string</span>
<span class="sd">Function that generates the symbolic code to perform the interpolation. Calling this function creates</span>
<span class="sd"> both the theano functions for the potential field and the block.</span>

<span class="sd">Returns:</span>
<span class="sd">    theano function for the potential field</span>
<span class="sd">    theano function for the block</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">theano</span>
<span class="kn">import</span> <span class="nn">theano.tensor</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="s1">&#39;fast_compile&#39;</span>
<span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">exception_verbosity</span> <span class="o">=</span> <span class="s1">&#39;high&#39;</span>
<span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">compute_test_value</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span>
<span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">profile_memory</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="TheanoGraph_pro"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro">[docs]</a><span class="k">class</span> <span class="nc">TheanoGraph_pro</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to help to divide the construction of the graph into sensical parts. All its methods build a part</span>
<span class="sd">    of the graph. Every method can be seen as a branch and collection of branches until the last method that will be the</span>
<span class="sd">    whole tree. Every part of the graph could be compiled separately but as we increase the complexity the input of each</span>
<span class="sd">    of these methods is more and more difficult to provide (if you are in a branch close to the trunk you need all the</span>
<span class="sd">    results of the branches above)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In the init we need to create all the symbolic parameters that are used in the process. Most of the variables</span>
<span class="sd">        are shared parameters initialized with random values. At this stage we only care about the type and shape of the</span>
<span class="sd">        parameters. After we have the graph built we can update the value of these shared parameters to our data (in the</span>
<span class="sd">        interpolatorClass).</span>
<span class="sd">        Args:</span>
<span class="sd">            u_grade: grade of the drift to compile the right graph. I found out that we can make a graph that takes this</span>
<span class="sd">            as variable so this argument will be deprecated soon</span>
<span class="sd">            verbose (list): name of the nodes you want to print</span>
<span class="sd">            dtype (str): type of float either 32 or 64</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Pass the verbose list as property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_all</span> <span class="o">=</span> <span class="kc">False</span>




        <span class="c1"># Creation of symbolic parameters</span>
        <span class="c1"># =============</span>
        <span class="c1"># Constants</span>
        <span class="c1"># =============</span>

        <span class="c1"># Arbitrary values to get the same results that GeoModeller. These parameters are a mystery for me yet. I have</span>
        <span class="c1"># to ask Gabi and Simon. In my humble opinion they weight the contribution of the interfaces against the</span>
        <span class="c1"># foliations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_reescale</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="mf">4.</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="mf">2.</span><span class="p">))</span>

        <span class="c1"># Number of dimensions. Now it is not too variable anymore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="c1"># ======================</span>
        <span class="c1"># INITIALIZE SHARED</span>
        <span class="c1"># ====================</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">),</span> <span class="s2">&quot;Grade of the universal drift&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="mf">1.</span><span class="p">),</span> <span class="s2">&quot;Range&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="mf">1.</span><span class="p">),</span> <span class="s1">&#39;Covariance at 0&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nugget_effect_grad_T</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="mf">0.01</span><span class="p">))</span>
        <span class="c1"># -DEP-</span>
        <span class="c1"># self.c_resc = theano.shared(np.cast[dtype](1), &quot;Rescaling factor&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))),</span> <span class="s1">&#39;Coordinates of the grid &#39;</span>
                                                                          <span class="s1">&#39;points to interpolate&#39;</span><span class="p">)</span>
        <span class="c1"># Shape is 9x2, 9 drift funcitons and 2 points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universal_grid_matrix_T</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>

        <span class="c1"># -DEP- Now I pass it as attribute when I create that part of the graph</span>
        <span class="c1">#self.n_faults = theano.shared(0, &#39;Number of faults to compute&#39;)#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">final_block</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))),</span> <span class="s2">&quot;Final block computed&quot;</span><span class="p">)</span>
        <span class="c1">#self.yet_simulated = theano.shared(np.ones(3, dtype=&#39;int64&#39;), &quot;Points to be computed yet&quot;)</span>

        <span class="c1"># This parameters give me the shape of the different groups of data. I pass all data together and I threshold it</span>
        <span class="c1"># using these values to the different potential fields and formations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_series_i</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">),</span> <span class="s1">&#39;Length of interfaces in every series&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_series_f</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">),</span> <span class="s1">&#39;Length of foliations in every series&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">),</span> <span class="s1">&#39;List with the number of formations&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_formation</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">),</span> <span class="s2">&quot;Value of the formation&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">))</span>

        <span class="c1"># ======================</span>
        <span class="c1"># VAR</span>
        <span class="c1">#=======================</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_all</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s2">&quot;Position of the dips&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles_all</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="s2">&quot;Angle of every dip&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_all</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="s2">&quot;Azimuth&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarity_all</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="s2">&quot;Polarity&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s2">&quot;Reference points for every layer&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s2">&quot;Rest of the points of the layers&quot;</span><span class="p">)</span>

        <span class="c1"># Tiling dips to the 3 spatial coordinations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_all</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># These are subsets of the data for each series. I initialized them as the whole arrays but then they will take</span>
        <span class="c1"># the data of every potential field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles_all</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_all</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity_all</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span>

        <span class="c1"># Block model out of the faults. It is initialized with shape(0, grid+ ref+rest) so if I do not change it during</span>
        <span class="c1"># the computation it does not have any effect</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">len_i_0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_i_1</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces_values</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="s1">&#39;potential_field_at_interfaces_values&#39;</span><span class="p">)</span>

       <span class="c1"># TODO tidy up this initializations</span>
      <span class="c1">#  self.final_potential_field_at_formations = T.zeros(self.n_formations_per_serie.get_value()[-1])</span>

      <span class="c1">#  self.pot_value = theano.shared(np.zeros(self.n_formations_per_serie.sum(), dtype=&#39;float64&#39;), &#39;average potential field&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_formations</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span><span class="c1">#np.array([], ndmin=1, dtype=dtype)) #T.vector(&#39;Final value of potential fields at interfacse&#39;, dtype=dtype)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_faults</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_formations_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_formations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_faults_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_faults</span>
        <span class="c1">#self.potential_field_at_interfaces_value   = theano.shared(np.cast[np.int64](np.zeros((2, 2))), &#39;Potential field value at each interface&#39;,)</span>

<div class="viewcode-block" id="TheanoGraph_pro.input_parameters_list"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.input_parameters_list">[docs]</a>    <span class="k">def</span> <span class="nf">input_parameters_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list with the symbolic variables to use when we compile the theano function</span>
<span class="sd">        Returns:</span>
<span class="sd">            list: [self.dips_position_all, self.dip_angles_all, self.azimuth_all, self.polarity_all,</span>
<span class="sd">                   self.ref_layer_points_all, self.rest_layer_points_all]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ipl</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position_all</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles_all</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_all</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity_all</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ipl</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.squared_euclidean_distances"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.squared_euclidean_distances">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">squared_euclidean_distances</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">x_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the euclidian distances in 3D between all the points in x_1 and x_2</span>
<span class="sd">        Args:</span>
<span class="sd">            x_1 (theano.tensor.matrix): shape n_points x number dimension</span>
<span class="sd">            x_2 (theano.tensor.matrix): shape n_points x number dimension</span>

<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: Distancse matrix. shape n_points x n_points</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># T.maximum avoid negative numbers increasing stability</span>
        <span class="n">sqd</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x_1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">x_2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">x_1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x_2</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="mi">0</span>
        <span class="p">))</span>

        <span class="k">return</span> <span class="n">sqd</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.matrices_shapes"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.matrices_shapes">[docs]</a>    <span class="k">def</span> <span class="nf">matrices_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the lengths of the matrices that form the covariance matrix</span>
<span class="sd">        Returns: length_of_CG, length_of_CGI, length_of_U_I, length_of_faults, length_of_C</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Calculating the dimensions of the</span>
        <span class="n">length_of_CG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">length_of_CGI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># if self.u_grade_T.get_value() == 0:</span>
        <span class="c1">#     length_of_U_I = 0*self.u_grade_T</span>
        <span class="c1"># else:</span>
        <span class="c1">#     length_of_U_I = 3**self.u_grade_T</span>
        <span class="n">length_of_U_I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span>
        <span class="n">length_of_faults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">length_of_C</span> <span class="o">=</span> <span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span> <span class="o">+</span> <span class="n">length_of_U_I</span> <span class="o">+</span> <span class="n">length_of_faults</span>

        <span class="k">if</span> <span class="s1">&#39;matrices_shapes&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">length_of_CG</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s2">&quot;length_of_CG&quot;</span><span class="p">)(</span><span class="n">length_of_CG</span><span class="p">)</span>
            <span class="n">length_of_CGI</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s2">&quot;length_of_CGI&quot;</span><span class="p">)(</span><span class="n">length_of_CGI</span><span class="p">)</span>
            <span class="n">length_of_U_I</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s2">&quot;length_of_U_I&quot;</span><span class="p">)(</span><span class="n">length_of_U_I</span><span class="p">)</span>
            <span class="n">length_of_faults</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s2">&quot;length_of_faults&quot;</span><span class="p">)(</span><span class="n">length_of_faults</span><span class="p">)</span>
            <span class="n">length_of_C</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s2">&quot;length_of_C&quot;</span><span class="p">)(</span><span class="n">length_of_C</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">length_of_CG</span><span class="p">,</span> <span class="n">length_of_CGI</span><span class="p">,</span> <span class="n">length_of_U_I</span><span class="p">,</span> <span class="n">length_of_faults</span><span class="p">,</span> <span class="n">length_of_C</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.cov_interfaces"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.cov_interfaces">[docs]</a>    <span class="k">def</span> <span class="nf">cov_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create covariance function for the interfaces</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: covariance of the interfaces. Shape number of points in rest x number of</span>
<span class="sd">            points in rest</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute euclidian distances</span>
        <span class="n">sed_rest_rest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">)</span>
        <span class="n">sed_ref_rest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">)</span>
        <span class="n">sed_rest_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">)</span>
        <span class="n">sed_ref_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">)</span>

        <span class="c1"># Covariance matrix for interfaces</span>
        <span class="n">C_I</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_reescale</span> <span class="o">*</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">sed_rest_rest</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># Rest - Rest Covariances Matrix</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
             <span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
             <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
             <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)</span> <span class="o">-</span>
            <span class="p">((</span><span class="n">sed_ref_rest</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># Reference - Rest</span>
             <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
              <span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
              <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
              <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span> <span class="o">-</span>
            <span class="p">((</span><span class="n">sed_rest_ref</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># Rest - Reference</span>
             <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
              <span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
              <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
              <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span> <span class="o">+</span>
            <span class="p">((</span><span class="n">sed_ref_ref</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># Reference - References</span>
             <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
              <span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
              <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
              <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))))</span> <span class="o">+</span> <span class="mf">1e-6</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">C_I</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Covariance Interfaces&#39;</span>
        <span class="k">return</span> <span class="n">C_I</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.cov_gradients"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.cov_gradients">[docs]</a>    <span class="k">def</span> <span class="nf">cov_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Create covariance function for the gradiens</span>
<span class="sd">         Returns:</span>
<span class="sd">             theano.tensor.matrix: covariance of the gradients. Shape number of points in dip_pos x number of</span>
<span class="sd">             points in dip_pos</span>

<span class="sd">         &quot;&quot;&quot;</span>

        <span class="c1"># Euclidean distances</span>
        <span class="n">sed_dips_dips</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span><span class="p">)</span>

        <span class="c1"># Cartesian distances between dips positions</span>
        <span class="n">h_u</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span>
            <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">),</span>
            <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">),</span>
            <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">))</span>

        <span class="c1"># Transpose</span>
        <span class="n">h_v</span> <span class="o">=</span> <span class="n">h_u</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Perpendicularity matrix. Boolean matrix to separate cross-covariance and</span>
        <span class="c1"># every gradient direction covariance (block diagonal)</span>
        <span class="n">perpendicularity_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sed_dips_dips</span><span class="p">)</span>

        <span class="c1"># Cross-covariances of x</span>
        <span class="n">perpendicularity_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
            <span class="n">perpendicularity_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Cross-covariances of y</span>
        <span class="n">perpendicularity_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
            <span class="n">perpendicularity_matrix</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Cross-covariances of z</span>
        <span class="n">perpendicularity_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
            <span class="n">perpendicularity_matrix</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Covariance matrix for gradients at every xyz direction and their cross-covariances</span>
        <span class="n">C_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span>
            <span class="n">T</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">sed_dips_dips</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># This is the condition</span>
            <span class="mi">0</span><span class="p">,</span>  <span class="c1"># If true it is equal to 0. This is how a direction affect another</span>
            <span class="p">(</span>  <span class="c1"># else, following Chiles book</span>
                <span class="p">(</span><span class="n">h_u</span> <span class="o">*</span> <span class="n">h_v</span> <span class="o">/</span> <span class="n">sed_dips_dips</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                <span class="p">((</span>
                     <span class="p">(</span><span class="n">sed_dips_dips</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># first derivative</span>
                     <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">14</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">105</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
                                     <span class="mi">35</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
                                     <span class="mi">21</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)))</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">sed_dips_dips</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># Second derivative</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span>
                                   <span class="mi">15</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span> <span class="o">-</span>
                <span class="p">(</span><span class="n">perpendicularity_matrix</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">sed_dips_dips</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># first derivative</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">14</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">105</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
                               <span class="mi">35</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
                               <span class="mi">21</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_dips</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)))</span>
        <span class="p">)</span>

        <span class="c1"># Setting nugget effect of the gradients</span>
        <span class="c1"># TODO: This function can be substitued by simply adding the nugget effect to the diag if I remove the condition</span>
        <span class="n">C_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">C_G</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">14</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nugget_effect_grad_T</span><span class="p">)</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">C_G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Covariance Gradient&#39;</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">pydotprint</span><span class="p">(</span><span class="n">C_G</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s2">&quot;graphs/&quot;</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">,</span>
                                       <span class="n">var_with_name_simple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">C_G</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;Cov Gradients&#39;</span><span class="p">)(</span><span class="n">C_G</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">C_G</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.cov_interface_gradients"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.cov_interface_gradients">[docs]</a>    <span class="k">def</span> <span class="nf">cov_interface_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create covariance function for the gradiens</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: covariance of the gradients. Shape number of points in rest x number of</span>
<span class="sd">              points in dip_pos</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Euclidian distances</span>
        <span class="n">sed_dips_rest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">)</span>
        <span class="n">sed_dips_ref</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">)</span>

        <span class="c1"># Cartesian distances between dips and interface points</span>
        <span class="c1"># Rest</span>
        <span class="n">hu_rest</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span>

        <span class="c1"># Reference point</span>
        <span class="n">hu_ref</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span>

        <span class="c1"># Cross-Covariance gradients-interfaces</span>
        <span class="n">C_GI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">hu_rest</span> <span class="o">*</span>
             <span class="p">(</span><span class="n">sed_dips_rest</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># first derivative</span>
             <span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">14</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">105</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_rest</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
                              <span class="mi">35</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sed_dips_rest</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
                              <span class="mi">21</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_rest</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)))</span> <span class="o">-</span>
            <span class="p">(</span><span class="n">hu_ref</span> <span class="o">*</span>
             <span class="p">(</span><span class="n">sed_dips_ref</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># first derivative</span>
             <span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">14</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">105</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_ref</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
                              <span class="mi">35</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sed_dips_ref</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
                              <span class="mi">21</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_ref</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">C_GI</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Covariance gradient interface&#39;</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_g&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">pydotprint</span><span class="p">(</span><span class="n">C_GI</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s2">&quot;graphs/&quot;</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">,</span>
                                       <span class="n">var_with_name_simple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C_GI</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.universal_matrix"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.universal_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">universal_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the drift matrices for the potential field and its gradient</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: Drift matrix for the interfaces. Shape number of points in rest x 3**degree drift</span>
<span class="sd">            (except degree 0 that is 0)</span>

<span class="sd">            theano.tensor.matrix: Drift matrix for the gradients. Shape number of points in dips x 3**degree drift</span>
<span class="sd">            (except degree 0 that is 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># # Init</span>
        <span class="c1"># U_I = None</span>
        <span class="c1"># U_G = None</span>
        <span class="c1">#</span>
        <span class="c1"># if self.u_grade_T.get_value() == 1:</span>
        <span class="c1">#     # ==========================</span>
        <span class="c1">#     # Condition of universality 1 degree</span>
        <span class="c1">#</span>
        <span class="c1">#     # Gradients</span>
        <span class="c1">#     n = self.dips_position.shape[0]</span>
        <span class="c1">#     U_G = T.zeros((n * self.n_dimensions, self.n_dimensions))</span>
        <span class="c1">#     # x</span>
        <span class="c1">#     U_G = T.set_subtensor(</span>
        <span class="c1">#         U_G[:n, 0], 1)</span>
        <span class="c1">#     # y</span>
        <span class="c1">#     U_G = T.set_subtensor(</span>
        <span class="c1">#         U_G[n:n * 2, 1], 1</span>
        <span class="c1">#     )</span>
        <span class="c1">#     # z</span>
        <span class="c1">#     U_G = T.set_subtensor(</span>
        <span class="c1">#         U_G[n * 2: n * 3, 2], 1</span>
        <span class="c1">#     )</span>
        <span class="c1">#</span>
        <span class="c1">#     # Interface</span>
        <span class="c1">#     # Cartesian distances between reference points and rest</span>
        <span class="c1">#     hx = T.stack(</span>
        <span class="c1">#         (self.rest_layer_points[:, 0] - self.ref_layer_points[:, 0]),</span>
        <span class="c1">#         (self.rest_layer_points[:, 1] - self.ref_layer_points[:, 1]),</span>
        <span class="c1">#         (self.rest_layer_points[:, 2] - self.ref_layer_points[:, 2])</span>
        <span class="c1">#     ).T</span>
        <span class="c1">#</span>
        <span class="c1">#     U_I = - hx * self.gi_reescale</span>


      <span class="c1">#  elif self.u_grade_T.get_value() == 2:</span>
        <span class="c1"># ==========================</span>
        <span class="c1"># Condition of universality 2 degree</span>
        <span class="c1"># Gradients</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">))</span>
        <span class="c1"># x</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># y</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># z</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># x**2</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># y**2</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># z**2</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># xy</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># This is y</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># This is x</span>
        <span class="c1"># xz</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># This is z</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># This is x</span>
        <span class="c1"># yz</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># This is z</span>
        <span class="n">U_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">U_G</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span><span class="n">n</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># This is y</span>

        <span class="c1"># Interface</span>
        <span class="n">U_I</span> <span class="o">=</span> <span class="o">-</span> <span class="n">T</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span>
             <span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="s1">&#39;U_I&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">U_I</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;U_I&#39;</span><span class="p">)(</span><span class="n">U_I</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;U_G&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">U_G</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;U_G&#39;</span><span class="p">)(</span><span class="n">U_G</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_g&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">pydotprint</span><span class="p">(</span><span class="n">U_I</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s2">&quot;graphs/&quot;</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="o">+</span> <span class="s2">&quot;_i.png&quot;</span><span class="p">,</span>
                                       <span class="n">var_with_name_simple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">pydotprint</span><span class="p">(</span><span class="n">U_G</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s2">&quot;graphs/&quot;</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="o">+</span> <span class="s2">&quot;_g.png&quot;</span><span class="p">,</span>
                                       <span class="n">var_with_name_simple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="k">if</span> <span class="n">U_I</span><span class="p">:</span>
            <span class="n">U_I</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Drift interfaces&#39;</span>
            <span class="n">U_G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Drift foliations&#39;</span>

        <span class="k">return</span> <span class="n">U_I</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span><span class="p">],</span> <span class="n">U_G</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span><span class="p">]</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.faults_matrix"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.faults_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">faults_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates the part of the graph that generates the faults function creating a &quot;block model&quot; at the</span>
<span class="sd">        references and the rest of the points. Then this vector has to be appended to the covariance function</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: Drift matrix for the interfaces. Shape number of points in rest x n faults. This drif</span>
<span class="sd">            is a simple addition of an arbitrary number</span>

<span class="sd">            theano.tensor.matrix: Drift matrix for the gradients. Shape number of points in dips x n faults. For</span>
<span class="sd">            discrete values this matrix will be null since the derivative of a constant is 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lenght_of_CG</span><span class="p">,</span> <span class="n">lenght_of_CGI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices_shapes</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># self.fault_matrix contains the faults volume of the grid and the rest and ref points. For the drift we need</span>
        <span class="c1"># to make it relative to the reference point</span>
      <span class="c1">#  self.len_points = self.rest_layer_points_all.shape[0]</span>
        <span class="n">interface_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span>

        <span class="n">fault_matrix_at_interfaces_rest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span><span class="p">[:,</span> <span class="n">interface_loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_i_0</span><span class="p">:</span> <span class="n">interface_loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_i_1</span><span class="p">]</span>
        <span class="n">fault_matrix_at_interfaces_ref</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span><span class="p">[:,</span> <span class="n">interface_loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_i_0</span><span class="p">:</span>
                                                               <span class="n">interface_loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_i_1</span><span class="p">]</span>

       <span class="c1"># len_points_i = 2*self.rest_layer_points_all.shape[0] + self.n_formation_op[0]-1</span>
       <span class="c1"># len_points_e = 2*self.rest_layer_points_all.shape[0] + self.n_formation_op[-1]-1</span>

     <span class="c1">#   F_I = (self.fault_matrix[:, -2*len_points:-len_points] - self.fault_matrix[:, -len_points:])[self.n_formation_op-1]</span>

        <span class="n">F_I</span> <span class="o">=</span> <span class="n">fault_matrix_at_interfaces_ref</span> <span class="o">-</span> <span class="n">fault_matrix_at_interfaces_rest</span>

        <span class="c1"># As long as the drift is a constant F_G is null</span>
        <span class="n">F_G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lenght_of_CG</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">F_I</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;Faults interfaces matrix&#39;</span><span class="p">)(</span><span class="n">F_I</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">F_I</span><span class="p">,</span> <span class="n">F_G</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.covariance_matrix"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.covariance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set all the previous covariances together in the universal cokriging matrix</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: Multivariate covariance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Lengths</span>
        <span class="n">length_of_CG</span><span class="p">,</span> <span class="n">length_of_CGI</span><span class="p">,</span> <span class="n">length_of_U_I</span><span class="p">,</span> <span class="n">length_of_faults</span><span class="p">,</span> <span class="n">length_of_C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices_shapes</span><span class="p">()</span>

        <span class="c1"># Individual matrices</span>
        <span class="n">C_G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_gradients</span><span class="p">()</span>
        <span class="n">C_I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_interfaces</span><span class="p">()</span>
        <span class="n">C_GI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_interface_gradients</span><span class="p">()</span>
        <span class="n">U_I</span><span class="p">,</span> <span class="n">U_G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universal_matrix</span><span class="p">()</span>
        <span class="n">F_I</span><span class="p">,</span> <span class="n">F_G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faults_matrix</span><span class="p">()</span>

        <span class="c1"># =================================</span>
        <span class="c1"># Creation of the Covariance Matrix</span>
        <span class="c1"># =================================</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">length_of_C</span><span class="p">,</span> <span class="n">length_of_C</span><span class="p">))</span>

        <span class="c1"># First row of matrices</span>
        <span class="c1"># Set C_G</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">],</span> <span class="n">C_G</span><span class="p">)</span>

        <span class="c1"># Set CGI</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">,</span> <span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">],</span> <span class="n">C_GI</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># TODO see if this condition is necesary. I think that simply by choosing len = 0 of the universal should work</span>
        <span class="c1"># (as I do in the fautls)</span>
        <span class="c1"># Set UG</span>
        <span class="c1">#if not self.u_grade_T.get_value() == 0:</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">,</span>
                                   <span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="p">:</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">],</span> <span class="n">U_G</span><span class="p">)</span>

        <span class="c1"># Set FG. I cannot use -index because when is -0 is equivalent to 0</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">,</span> <span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">:],</span> <span class="n">F_G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Second row of matrices</span>
        <span class="c1"># Set C_IG</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">],</span> <span class="n">C_GI</span><span class="p">)</span>

        <span class="c1"># Set C_I</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">,</span>
                                   <span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">],</span> <span class="n">C_I</span><span class="p">)</span>

        <span class="c1"># Set U_I</span>
        <span class="c1">#if not self.u_grade_T.get_value() == 0:</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">,</span>
                                   <span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="p">:</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">],</span> <span class="n">U_I</span><span class="p">)</span>

        <span class="c1"># Set F_I</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">,</span> <span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">:],</span> <span class="n">F_I</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># Third row of matrices</span>
            <span class="c1"># Set U_G</span>
       <span class="c1"># if not self.u_grade_T.get_value() == 0:</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="p">:</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">],</span> <span class="n">U_G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Set U_I</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="p">:</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">,</span> <span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">],</span> <span class="n">U_I</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Fourth row of matrices</span>
        <span class="c1"># Set F_G</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">length_of_CG</span><span class="p">],</span> <span class="n">F_G</span><span class="p">)</span>

        <span class="c1"># Set F_I</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">[</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">:,</span> <span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">],</span> <span class="n">F_I</span><span class="p">)</span>

        <span class="c1"># TODO: deprecate</span>
        <span class="c1"># -DEP-</span>
        <span class="c1">#  self.C_matrix = C_matrix</span>
        <span class="c1"># Add name to the theano node</span>
        <span class="n">C_matrix</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Block Covariance Matrix&#39;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">C_matrix</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;cov_function&#39;</span><span class="p">)(</span><span class="n">C_matrix</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">C_matrix</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.b_vector"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.b_vector">[docs]</a>    <span class="k">def</span> <span class="nf">b_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creation of the independent vector b to solve the kriging system</span>
<span class="sd">        Args:</span>
<span class="sd">            verbose: -deprecated-</span>

<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: independent vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">length_of_C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices_shapes</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># =====================</span>
        <span class="c1"># Creation of the gradients G vector</span>
        <span class="c1"># Calculation of the cartesian components of the dips assuming the unit module</span>
        <span class="n">G_x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dip_angles</span><span class="p">))</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span>
        <span class="n">G_y</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dip_angles</span><span class="p">))</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span>
        <span class="n">G_z</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dip_angles</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">G_x</span><span class="p">,</span> <span class="n">G_y</span><span class="p">,</span> <span class="n">G_z</span><span class="p">))</span>

        <span class="c1"># Creation of the Dual Kriging vector</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">length_of_C</span><span class="p">,))</span>
       <span class="c1"># G = T.tile(G, (1, 1)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">G</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">pydotprint</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s2">&quot;graphs/&quot;</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="o">+</span> <span class="s2">&quot;_i.png&quot;</span><span class="p">,</span>
                                       <span class="n">var_with_name_simple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;b vector&#39;</span><span class="p">)(</span><span class="n">b</span><span class="p">)</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">b</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;b vector&#39;</span>
        <span class="k">return</span> <span class="n">b</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.solve_kriging"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.solve_kriging">[docs]</a>    <span class="k">def</span> <span class="nf">solve_kriging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the kriging system. This has to get substituted by a more efficient and stable method QR</span>
<span class="sd">        decomposition in all likelihood</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: Dual kriging parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_vector</span><span class="p">()</span>
        <span class="c1"># Solving the kriging system</span>
        <span class="c1"># TODO: look for an eficient way to substitute nlianlg by a theano operation</span>
        <span class="kn">import</span> <span class="nn">theano.tensor.slinalg</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">DK_parameters</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">slinalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">C_matrix</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
        <span class="n">DK_parameters</span> <span class="o">=</span> <span class="n">DK_parameters</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">DK_parameters</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
      <span class="c1">#  DK_parameters = T.dot(T.nlinalg.matrix_inverse(C_matrix), b)</span>
        <span class="c1"># Add name to the theano node</span>
        <span class="n">DK_parameters</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Dual Kriging parameters&#39;</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">DK_parameters</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">DK_parameters</span><span class="o">.</span><span class="n">name</span> <span class="p">)(</span><span class="n">DK_parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DK_parameters</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.x_to_interpolate"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.x_to_interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">x_to_interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        here I add to the grid points also the references points(to check the value of the potential field at the</span>
<span class="sd">        interfaces). Also here I will check what parts of the grid have been already computed in a previous series</span>
<span class="sd">        to avoid to recompute.</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: The 3D points of the given grid plus the reference and rest points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#yet_simulated = self.yet_simulated_func()</span>

        <span class="c1"># Removing points no simulated</span>
        <span class="n">pns</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">nonzero_values</span><span class="p">()</span>

        <span class="c1"># Adding the rest interface points</span>
        <span class="n">grid_val</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span><span class="n">pns</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">)</span>

        <span class="c1"># Adding the ref interface points</span>
        <span class="n">grid_val</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span><span class="n">grid_val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">)</span>

        <span class="c1"># Removing points no simulated</span>
       <span class="c1"># grid_val = (grid_val* self.yet_simulated.reshape((self.yet_simulated.shape[0], 1))).nonzero_values()</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">pydotprint</span><span class="p">(</span><span class="n">grid_val</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s2">&quot;graphs/&quot;</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">,</span>
                                       <span class="n">var_with_name_simple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;grid_val&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">grid_val</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;Points to interpolate&#39;</span><span class="p">)(</span><span class="n">grid_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid_val</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.extend_dual_kriging"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.extend_dual_kriging">[docs]</a>    <span class="k">def</span> <span class="nf">extend_dual_kriging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tile the dual kriging vector to cover all the points to interpolate.So far I just make a matrix with the</span>
<span class="sd">        dimensions len(DK)x(grid) but in the future maybe I have to try to loop all this part so consume less memory</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: Matrix with the Dk parameters repeated for all the points to interpolate</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grid_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_to_interpolate</span><span class="p">()</span>
        <span class="n">DK_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_kriging</span><span class="p">()</span>


        <span class="c1"># Creation of a matrix of dimensions equal to the grid with the weights for every point (big 4D matrix in</span>
        <span class="c1"># ravel form)</span>
        <span class="n">DK_weights</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">DK_parameters</span><span class="p">,</span> <span class="p">(</span><span class="n">grid_val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">DK_weights</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.gradient_contribution"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.gradient_contribution">[docs]</a>    <span class="k">def</span> <span class="nf">gradient_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computation of the contribution of the foliations at every point to interpolate</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: Contribution of all foliations (input) at every point to interpolate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend_dual_kriging</span><span class="p">()</span>
        <span class="n">length_of_CG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices_shapes</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">grid_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_to_interpolate</span><span class="p">()</span>

        <span class="c1"># Cartesian distances between the point to simulate and the dips</span>
        <span class="n">hu_SimPoint</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid_val</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">grid_val</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid_val</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">grid_val</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid_val</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">grid_val</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span>

        <span class="c1"># Euclidian distances</span>
        <span class="n">sed_dips_SimPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span><span class="p">,</span> <span class="n">grid_val</span><span class="p">)</span>

        <span class="c1"># Gradient contribution</span>
        <span class="n">sigma_0_grad</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">weights</span><span class="p">[:</span><span class="n">length_of_CG</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span>
             <span class="p">(</span><span class="o">-</span><span class="n">hu_SimPoint</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">sed_dips_SimPoint</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># first derivative</span>
              <span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">14</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">105</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
                               <span class="mi">35</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sed_dips_SimPoint</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
                               <span class="mi">21</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sed_dips_SimPoint</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)))),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">sigma_0_grad</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Contribution of the foliations to the potential field at every point of the grid&#39;</span>

        <span class="k">return</span> <span class="n">sigma_0_grad</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.interface_contribution"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.interface_contribution">[docs]</a>    <span class="k">def</span> <span class="nf">interface_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Computation of the contribution of the interfaces at every point to interpolate</span>
<span class="sd">          Returns:</span>
<span class="sd">              theano.tensor.vector: Contribution of all interfaces (input) at every point to interpolate</span>
<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend_dual_kriging</span><span class="p">()</span>
        <span class="n">length_of_CG</span><span class="p">,</span> <span class="n">length_of_CGI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices_shapes</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">grid_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_to_interpolate</span><span class="p">()</span>

        <span class="c1"># Euclidian distances</span>
        <span class="n">sed_rest_SimPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span><span class="p">,</span> <span class="n">grid_val</span><span class="p">)</span>
        <span class="n">sed_ref_SimPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span><span class="p">,</span> <span class="n">grid_val</span><span class="p">)</span>

        <span class="c1"># Interface contribution</span>
        <span class="n">sigma_0_interf</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="o">-</span><span class="n">weights</span><span class="p">[</span><span class="n">length_of_CG</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_o_T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_reescale</span> <span class="o">*</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">sed_rest_SimPoint</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># SimPoint - Rest Covariances Matrix</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                 <span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
                 <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
                 <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_rest_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)</span> <span class="o">-</span>
                <span class="p">((</span><span class="n">sed_ref_SimPoint</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">*</span>  <span class="c1"># SimPoint- Ref</span>
                 <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                  <span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span>
                  <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span>
                  <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">sed_ref_SimPoint</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">sigma_0_interf</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Contribution of the interfaces to the potential field at every point of the grid&#39;</span>

        <span class="k">return</span> <span class="n">sigma_0_interf</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.universal_drift_contribution"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.universal_drift_contribution">[docs]</a>    <span class="k">def</span> <span class="nf">universal_drift_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computation of the contribution of the universal drift at every point to interpolate</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: Contribution of the universal drift (input) at every point to interpolate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend_dual_kriging</span><span class="p">()</span>
        <span class="n">length_of_CG</span><span class="p">,</span> <span class="n">length_of_CGI</span><span class="p">,</span> <span class="n">length_of_U_I</span><span class="p">,</span> <span class="n">length_of_faults</span><span class="p">,</span> <span class="n">length_of_C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices_shapes</span><span class="p">()</span>
        <span class="n">grid_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_to_interpolate</span><span class="p">()</span>

        <span class="c1"># Universal drift contribution</span>
        <span class="c1"># Universal terms used to calculate f0</span>
        <span class="c1"># -DEP-</span>
        <span class="c1"># _universal_terms_layers = T.horizontal_stack(</span>
        <span class="c1">#     self.rest_layer_points,</span>
        <span class="c1">#     (self.rest_layer_points ** 2),</span>
        <span class="c1">#     T.stack((self.rest_layer_points[:, 0] * self.rest_layer_points[:, 1],</span>
        <span class="c1">#              self.rest_layer_points[:, 0] * self.rest_layer_points[:, 2],</span>
        <span class="c1">#              self.rest_layer_points[:, 1] * self.rest_layer_points[:, 2]), axis=1)).T</span>

        <span class="c1"># if self.u_grade_T.get_value() == 0:</span>
        <span class="c1">#     f_0 = 0</span>
        <span class="c1"># else:</span>
        <span class="c1"># Here I create the universal terms for rest and ref. The universal terms for the grid are done in python</span>
        <span class="c1"># and append here. The idea is that the grid is kind of constant so I do not have to recompute it every</span>
        <span class="c1"># time</span>
        <span class="n">_universal_terms_interfaces_rest</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">horizontal_stack</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">T</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">_universal_terms_interfaces_ref</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">horizontal_stack</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">T</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># _universal_terms_interfaces = T.horizontal_stack(</span>
        <span class="c1">#     self.rest_layer_points_all,</span>
        <span class="c1">#     (self.rest_layer_points_all ** 2),</span>
        <span class="c1">#     T.stack((self.rest_layer_points_all[:, 0] * self.rest_layer_points_all[:, 1],</span>
        <span class="c1">#              self.rest_layer_points_all[:, 0] * self.rest_layer_points_all[:, 2],</span>
        <span class="c1">#              self.rest_layer_points_all[:, 1] * self.rest_layer_points_all[:, 2]), axis=1)).T</span>

        <span class="c1"># I append rest and ref to grid</span>
        <span class="n">universal_grid_interfaces_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">horizontal_stack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universal_grid_matrix_T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero_values</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span><span class="n">_universal_terms_interfaces_rest</span><span class="p">,</span> <span class="n">_universal_terms_interfaces_ref</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
          <span class="c1">#  T.tile(_universal_terms_interfaces, (1, 2)))</span>

        <span class="c1"># These are the magic terms to get the same as geomodeller</span>
        <span class="n">gi_rescale_aux</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
        <span class="n">gi_rescale_aux</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">gi_rescale_aux</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">_aux_magic_term</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">gi_rescale_aux</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span><span class="p">],</span> <span class="p">(</span><span class="n">grid_val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Drif contribution</span>
        <span class="n">f_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span><span class="p">:</span><span class="n">length_of_CG</span> <span class="o">+</span> <span class="n">length_of_CGI</span> <span class="o">+</span> <span class="n">length_of_U_I</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gi_reescale</span> <span class="o">*</span> <span class="n">_aux_magic_term</span> <span class="o">*</span>
            <span class="n">universal_grid_interfaces_matrix</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span><span class="p">]</span>
            <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">f_0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">f_0</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Contribution of the universal drift to the potential field at every point of the grid&#39;</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">f_0</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;Universal terms contribution&#39;</span><span class="p">)(</span><span class="n">f_0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f_0</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.faults_contribution"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.faults_contribution">[docs]</a>    <span class="k">def</span> <span class="nf">faults_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computation of the contribution of the faults drift at every point to interpolate. To get these we need to</span>
<span class="sd">        compute a whole block model with the faults data</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: Contribution of the faults drift (input) at every point to interpolate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend_dual_kriging</span><span class="p">()</span>
        <span class="n">length_of_CG</span><span class="p">,</span> <span class="n">length_of_CGI</span><span class="p">,</span> <span class="n">length_of_U_I</span><span class="p">,</span> <span class="n">length_of_faults</span><span class="p">,</span> <span class="n">length_of_C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices_shapes</span><span class="p">()</span>
        <span class="n">grid_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_to_interpolate</span><span class="p">()</span>

        <span class="c1"># Contribution</span>
        <span class="n">f_1</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">length_of_CG</span><span class="o">+</span><span class="n">length_of_CGI</span><span class="o">+</span><span class="n">length_of_U_I</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="n">grid_val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">f_1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Faults contribution&#39;</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">f_1</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;Faults contribution&#39;</span><span class="p">)(</span><span class="n">f_1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f_1</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.potential_field_at_all"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.potential_field_at_all">[docs]</a>    <span class="k">def</span> <span class="nf">potential_field_at_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the potential field at all the interpolation points, i.e. grid plus rest plus ref</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: Potential fields at all points</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_0_grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient_contribution</span><span class="p">()</span>
        <span class="n">sigma_0_interf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface_contribution</span><span class="p">()</span>
        <span class="n">f_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universal_drift_contribution</span><span class="p">()</span>
        <span class="n">f_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faults_contribution</span><span class="p">()</span>
        <span class="c1"># -DEP-</span>
        <span class="c1"># length_of_CGI = self.matrices_shapes()[1]</span>

        <span class="n">Z_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_0_grad</span> <span class="o">+</span> <span class="n">sigma_0_interf</span> <span class="o">+</span> <span class="n">f_0</span> <span class="o">+</span> <span class="n">f_1</span><span class="p">)</span><span class="c1">#[:-2*self.rest_layer_points_all.shape[0]]</span>


        <span class="c1"># Add an arbitrary number at the potential field to get unique values for each of them</span>
        <span class="n">Z_x</span> <span class="o">+=</span> <span class="n">T</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">Z_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Z_x</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Value of the potential field at every point&#39;</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">Z_x</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;Potential field at all points&#39;</span><span class="p">)(</span><span class="n">Z_x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z_x</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.potential_field_at_interfaces"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.potential_field_at_interfaces">[docs]</a>    <span class="k">def</span> <span class="nf">potential_field_at_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Potential field at interfaces. To avoid errors I take all the points of rest that belong to one interface</span>
<span class="sd">        and make the average</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: Potential field values at the interfaces of a given series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_0_grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient_contribution</span><span class="p">()</span>
        <span class="n">sigma_0_interf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface_contribution</span><span class="p">()</span>
        <span class="n">f_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universal_drift_contribution</span><span class="p">()</span>
        <span class="n">f_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faults_contribution</span><span class="p">()</span>
        <span class="c1"># -DEP-</span>
        <span class="c1">#length_of_CGI = self.matrices_shapes()[1]</span>

        <span class="n">potential_field_interfaces</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_0_grad</span> <span class="o">+</span> <span class="n">sigma_0_interf</span> <span class="o">+</span> <span class="n">f_0</span> <span class="o">+</span> <span class="n">f_1</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">]</span>

        <span class="n">npf</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">T</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span><span class="p">)))</span>

        <span class="c1"># Loop to obtain the average Zx for every intertace</span>
        <span class="k">def</span> <span class="nf">average_potential</span><span class="p">(</span><span class="n">dim_a</span><span class="p">,</span> <span class="n">dim_b</span><span class="p">,</span> <span class="n">pfi</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function to make the average of the potential field at an interface</span>
<span class="sd">            Args:</span>
<span class="sd">                dim: size of the rest values vector per formation</span>
<span class="sd">                pfi: the values of all the rest values potentials</span>
<span class="sd">            Return:</span>
<span class="sd">                theano.tensor.vector: average of the potential per formation</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">average</span> <span class="o">=</span> <span class="n">pfi</span><span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dim_a</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">):</span> <span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dim_b</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">((</span><span class="n">dim_b</span> <span class="o">-</span> <span class="n">dim_a</span><span class="p">),</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">average</span>  <span class="c1"># , {self.pot_value: T.stack([average])}</span>

        <span class="n">potential_field_interfaces_unique</span><span class="p">,</span> <span class="n">updates1</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
            <span class="n">fn</span><span class="o">=</span><span class="n">average_potential</span><span class="p">,</span>
            <span class="n">outputs_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sequences</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">npf</span><span class="p">,</span>
                           <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
            <span class="n">non_sequences</span><span class="o">=</span><span class="n">potential_field_interfaces</span><span class="p">)</span>

      <span class="c1">#  self.potential_field_at_interfaces_value = theano.shared(self.updates1)</span>
      <span class="c1">#  self.potential_field_at_interfaces_value.set_value(updates1)</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">potential_field_interfaces_unique</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Value of the potential field at the interfaces&#39;</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">potential_field_interfaces_unique</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">potential_field_interfaces_unique</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>\
                                                                      <span class="p">(</span><span class="n">potential_field_interfaces_unique</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">potential_field_interfaces_unique</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.block_series"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.block_series">[docs]</a>    <span class="k">def</span> <span class="nf">block_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the part of the block model of a given series (dictated by the bool array yet to be computed)</span>
<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.vector: Value of lithology at every interpolated point</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Graph to compute the potential field</span>
        <span class="n">Z_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_all</span><span class="p">()</span>

        <span class="c1"># Max and min values of the potential field.</span>
        <span class="c1"># TODO this may be expensive because I guess that is a sort algorithm. We just need a +inf and -inf... I guess</span>
        <span class="n">max_pot</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Z_x</span><span class="p">)</span>  <span class="c1">#T.max(potential_field_unique) + 1</span>
        <span class="n">min_pot</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Z_x</span><span class="p">)</span>   <span class="c1">#T.min(potential_field_unique) - 1</span>

        <span class="c1"># Value of the potential field at the interfaces of the computed series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces_values</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces_values</span> <span class="o">+=</span> <span class="n">T</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># self.pot_field_for_faults = potential_field_at_interfaces_values</span>
        <span class="c1"># self.pot_field_for_formations = potential_field_at_interfaces_values</span>

                                <span class="c1">#T.concatenate((self.final_potential_field_at_interfaces,</span>
                                                   <span class="c1">#  potential_field_at_interfaces_values))</span>


        <span class="c1"># A tensor with the values to segment</span>
        <span class="n">potential_field_iter</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">T</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">max_pot</span><span class="p">]),</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces_values</span><span class="p">,</span>
                                              <span class="n">T</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">min_pot</span><span class="p">])))</span>

        <span class="k">if</span> <span class="s2">&quot;potential_field_iter&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">potential_field_iter</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s2">&quot;potential_field_iter&quot;</span><span class="p">)(</span><span class="n">potential_field_iter</span><span class="p">)</span>

        <span class="c1"># if &quot;potential_field_at_interfaces_values&quot;:</span>
        <span class="c1">#     self.potential_field_at_interfaces_values = theano.printing.Print(&#39;Potential field&#39;)(</span>
        <span class="c1">#         self.potential_field_at_interfaces())</span>
        <span class="c1">#     self.potential_field_at_interfaces_values = theano.printing.Print(&#39;Selected pt&#39;)(</span>
        <span class="c1">#         #self.potential_field_at_interfaces_values[self.n_formation_op - 1])</span>
        <span class="c1">#         T.sort(self.potential_field_at_interfaces()[self.n_formation_op - 1])[::-1])</span>

        <span class="c1"># Loop to segment the distinct lithologies</span>
        <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n_formation</span><span class="p">,</span> <span class="n">Zx</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Treshold of the points to interpolate given 2 potential field values. TODO: This function is the one we</span>
<span class="sd">            need to change for a sigmoid function</span>
<span class="sd">            Args:</span>
<span class="sd">                a (scalar): Upper limit of the potential field</span>
<span class="sd">                b (scalar): Lower limit of the potential field</span>
<span class="sd">                n_formation (scalar): Value given to the segmentation, i.e. lithology number</span>
<span class="sd">                Zx (vector): Potential field values at all the interpolated points</span>

<span class="sd">            Returns:</span>
<span class="sd">                theano.tensor.vector: segmented values</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">Zx</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">Zx</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_formation</span>

        <span class="n">partial_block</span><span class="p">,</span> <span class="n">updates2</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
            <span class="n">fn</span><span class="o">=</span><span class="n">compare</span><span class="p">,</span>
            <span class="n">outputs_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sequences</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">potential_field_iter</span><span class="p">,</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span><span class="p">],</span>
            <span class="n">non_sequences</span><span class="o">=</span><span class="n">Z_x</span><span class="p">)</span>

        <span class="c1"># For every formation we get a vector so we need to sum compress them to one dimension</span>
        <span class="n">partial_block</span> <span class="o">=</span> <span class="n">partial_block</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Add name to the theano node</span>
        <span class="n">partial_block</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;The chunk of block model of a specific series&#39;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">partial_block</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">partial_block</span><span class="o">.</span><span class="n">name</span><span class="p">)(</span><span class="n">partial_block</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">partial_block</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.compute_a_fault"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.compute_a_fault">[docs]</a>    <span class="k">def</span> <span class="nf">compute_a_fault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">len_i_0</span><span class="p">,</span> <span class="n">len_i_1</span><span class="p">,</span>
                        <span class="n">len_f_0</span><span class="p">,</span> <span class="n">len_f_1</span><span class="p">,</span>
                        <span class="n">n_form_per_serie_0</span><span class="p">,</span> <span class="n">n_form_per_serie_1</span><span class="p">,</span>
                        <span class="n">u_grade_iter</span><span class="p">,</span>
                        <span class="n">final_block</span>
                        <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that loops each fault, generating a potential field for each on them with the respective block model</span>
<span class="sd">        Args:</span>
<span class="sd">            len_i_0: Lenght of rest of previous series</span>
<span class="sd">            len_i_1: Lenght of rest for the computed series</span>
<span class="sd">            len_f_0: Lenght of dips of previous series</span>
<span class="sd">            len_f_1: Length of dips of the computed series</span>
<span class="sd">            n_form_per_serie_0: Number of formations of previous series</span>
<span class="sd">            n_form_per_serie_1: Number of formations of the computed series</span>

<span class="sd">        Returns:</span>
<span class="sd">            theano.tensor.matrix: block model derived from the faults that afterwards is used as a drift for the &quot;real&quot;</span>
<span class="sd">            data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># THIS IS THE FAULTS BLOCK.</span>
        <span class="c1"># ==================</span>
        <span class="c1"># Preparing the data</span>
        <span class="c1"># ==================</span>

        <span class="c1"># TODO in order to make faults networks I will have to activate the yet simulated. The idea is that first we</span>
        <span class="c1"># compute the youngest fault and consecutively the others</span>

        <span class="c1"># -DEP- Until I add network faults</span>
      <span class="c1">#  self.yet_simulated = T.eq(final_block[0, :], 0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">final_block</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Yet simulated FAULTS node&#39;</span>
        <span class="c1">#self.yet_simulated.name = &#39;Yet simulated node&#39;</span>

        <span class="c1"># Slice the matrices for the corresponding series</span>

        <span class="c1"># Theano shared</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points_per_formation_T_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span><span class="p">[</span><span class="n">n_form_per_serie_0</span><span class="p">:</span> <span class="n">n_form_per_serie_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_formation</span><span class="p">[</span><span class="n">n_form_per_serie_0</span><span class="p">:</span> <span class="n">n_form_per_serie_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span> <span class="o">=</span> <span class="n">u_grade_iter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Theano Var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[</span><span class="n">len_i_0</span><span class="p">:</span> <span class="n">len_i_1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[</span><span class="n">len_i_0</span><span class="p">:</span> <span class="n">len_i_1</span><span class="p">,</span> <span class="p">:]</span>

       <span class="c1"># self.fault_matrix_at_rest = self.fault_matrix[]</span>
       <span class="c1"># self.fault_matrix_at_ref =</span>




        <span class="k">if</span> <span class="s1">&#39;n_formation&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;n_formation_fault&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span><span class="p">)</span>

        <span class="c1"># ====================</span>
        <span class="c1"># Computing the series</span>
        <span class="c1"># ====================</span>
       <span class="c1"># faults_matrix = self.block_series()</span>

        <span class="n">faults_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_series</span><span class="p">()</span>
        <span class="n">aux_ones</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">])</span>
        <span class="n">faults_select</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="p">,</span> <span class="n">aux_ones</span><span class="p">))</span>

        <span class="c1"># Update the block matrix</span>
        <span class="n">block_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
                    <span class="n">final_block</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">faults_select</span><span class="p">,</span> <span class="s2">&quot;int8&quot;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">faults_matrix</span><span class="p">)</span>

        <span class="c1"># Update the potential field matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_all</span><span class="p">:</span>
            <span class="n">potential_field_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_all</span><span class="p">()</span>

            <span class="n">block_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
                <span class="n">block_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">faults_select</span><span class="p">,</span> <span class="s2">&quot;int8&quot;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">potential_field_values</span><span class="p">)</span>

        <span class="c1"># Store the potential field at the interfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_faults_op</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_faults_op</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces_values</span><span class="p">)</span>
        <span class="c1"># Save potential field at interfaces</span>
        <span class="c1"># self.final_potential_field_at_interfaces = T.concatenate([self.final_potential_field_at_interfaces,</span>
        <span class="c1">#                                                           self.potential_field_at_interfaces_values])</span>

        <span class="c1"># -DEP- Until I add network faults</span>
        <span class="c1">#final_block = T.set_subtensor(</span>
        <span class="c1">#    final_block[T.nonzero(T.cast(self.yet_simulated, &quot;int8&quot;))[0]],</span>
        <span class="c1">#    potential_field_contribution)</span>

        <span class="k">return</span> <span class="n">block_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_faults_op</span></div>

<div class="viewcode-block" id="TheanoGraph_pro.compute_a_series"><a class="viewcode-back" href="../code.html#theanograf.TheanoGraph_pro.compute_a_series">[docs]</a>    <span class="k">def</span> <span class="nf">compute_a_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">len_i_0</span><span class="p">,</span> <span class="n">len_i_1</span><span class="p">,</span>
                         <span class="n">len_f_0</span><span class="p">,</span> <span class="n">len_f_1</span><span class="p">,</span>
                         <span class="n">n_form_per_serie_0</span><span class="p">,</span> <span class="n">n_form_per_serie_1</span><span class="p">,</span>
                         <span class="n">u_grade_iter</span><span class="p">,</span>
                         <span class="n">final_block</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that loops each series, generating a potential field for each on them with the respective block model</span>
<span class="sd">        Args:</span>
<span class="sd">             len_i_0: Lenght of rest of previous series</span>
<span class="sd">             len_i_1: Lenght of rest for the computed series</span>
<span class="sd">             len_f_0: Lenght of dips of previous series</span>
<span class="sd">             len_f_1: Length of dips of the computed series</span>
<span class="sd">             n_form_per_serie_0: Number of formations of previous series</span>
<span class="sd">             n_form_per_serie_1: Number of formations of the computed series</span>

<span class="sd">        Returns:</span>
<span class="sd">             theano.tensor.matrix: final block model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># THIS IS THE FINAL BLOCK. (DO I NEED TO LOOP THE FAULTS FIRST? Yes you do)</span>
        <span class="c1"># ==================</span>
        <span class="c1"># Preparing the data</span>
        <span class="c1"># ==================</span>
        <span class="c1"># Vector that controls the points that have been simulated in previous iterations</span>
        <span class="c1">#self.yet_simulated = T.eq(final_block[0, :], 0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">final_block</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Yet simulated LITHOLOGY node&#39;</span>

        <span class="c1"># Theano shared</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points_per_formation_T_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span><span class="p">[</span><span class="n">n_form_per_serie_0</span><span class="p">:</span> <span class="n">n_form_per_serie_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_formation</span><span class="p">[</span><span class="n">n_form_per_serie_0</span><span class="p">:</span> <span class="n">n_form_per_serie_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T_op</span> <span class="o">=</span> <span class="n">u_grade_iter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dips_position_tiled</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dips_position</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Theano Var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dip_angles_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity_all</span><span class="p">[</span><span class="n">len_f_0</span><span class="p">:</span> <span class="n">len_f_1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points_all</span><span class="p">[</span><span class="n">len_i_0</span><span class="p">:</span> <span class="n">len_i_1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_layer_points_all</span><span class="p">[</span><span class="n">len_i_0</span><span class="p">:</span> <span class="n">len_i_1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># For the contribution of the faults I did not find a better way</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_i_0</span> <span class="o">=</span> <span class="n">len_i_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_i_1</span> <span class="o">=</span> <span class="n">len_i_1</span>

        <span class="c1"># Printing</span>
        <span class="k">if</span> <span class="s1">&#39;yet_simulated&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="o">.</span><span class="n">name</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;n_formation&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s1">&#39;n_formation_series&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span><span class="p">)</span>



        <span class="c1"># ====================</span>
        <span class="c1"># Computing the series</span>
        <span class="c1"># ====================</span>

        <span class="n">aux_ones</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">])</span>
        <span class="n">lith_select</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span><span class="p">,</span> <span class="n">aux_ones</span><span class="p">))</span>

        <span class="n">potential_field_contribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_series</span><span class="p">()</span>  <span class="c1">#[:-2*self.len_points]</span>

        <span class="c1"># Updating the block model with the lithology block</span>
        <span class="n">final_block</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
            <span class="n">final_block</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">lith_select</span><span class="p">,</span> <span class="s2">&quot;int8&quot;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]],</span>
            <span class="n">potential_field_contribution</span><span class="p">)</span>

        <span class="c1"># Store the potential field at the interfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_formations_op</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_formations_op</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formation_op</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_interfaces_values</span><span class="p">)</span>

        <span class="c1"># Update the potential field matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_all</span><span class="p">:</span>
            <span class="n">potential_field_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential_field_at_all</span><span class="p">()</span><span class="c1">#[:-2*self.len_points]</span>

            <span class="n">final_block</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span>
            <span class="n">final_block</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">lith_select</span><span class="p">,</span> <span class="s2">&quot;int8&quot;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">potential_field_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">final_block</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_potential_field_at_formations_op</span></div>

    <span class="c1"># def whole_block_model(self, n_faults=0, compute_all=True):</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Final function that loops first all the faults, then uses that result in the final block and loops again the</span>
    <span class="c1">#     series</span>
    <span class="c1">#     Args:</span>
    <span class="c1">#         n_faults (int): Number of faults to extract the correct values from the big input matrices</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         theano.tensor.vector: Final block model with the segmented lithologies</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # TODO move this to init</span>
    <span class="c1">#     self.compute_all = False</span>
    <span class="c1">#</span>
    <span class="c1">#     final_block_init = self.final_block</span>
    <span class="c1">#     final_block_init.name = &#39;final block of lithologies init&#39;</span>
    <span class="c1">#</span>
    <span class="c1">#     # Check if there are faults and loop them to create the Faults block</span>
    <span class="c1">#     if n_faults != 0:</span>
    <span class="c1">#         # we initialize the final block</span>
    <span class="c1">#         fault_block_init = T.zeros((2, self.grid_val_T.shape[0]+2*self.len_points))  # self.final_block</span>
    <span class="c1">#         fault_block_init.name = &#39;final block of faults init&#39;</span>
    <span class="c1">#         self.yet_simulated = T.eq(fault_block_init[0, :-2*self.len_points], 0)</span>
    <span class="c1">#</span>
    <span class="c1">#         fault_loop, updates3 = theano.scan(</span>
    <span class="c1">#              fn=self.compute_a_fault,</span>
    <span class="c1">#              outputs_info=[fault_block_init, None],  #  This line may be used for the faults network</span>
    <span class="c1">#              sequences=[dict(input=self.len_series_i[:n_faults+1], taps=[0, 1]),</span>
    <span class="c1">#                         dict(input=self.len_series_f[:n_faults+1], taps=[0, 1]),</span>
    <span class="c1">#                         dict(input=self.n_formations_per_serie[:n_faults+1], taps=[0, 1]),</span>
    <span class="c1">#                         dict(input=self.u_grade_T[:n_faults + 1], taps=[0])]</span>
    <span class="c1">#              )</span>
    <span class="c1">#         # fault_matrix, updates3 = theano.scan(</span>
    <span class="c1">#         #     fn=self.compute_a_series,</span>
    <span class="c1">#         #     outputs_info=final_block_init,</span>
    <span class="c1">#         #     sequences=[dict(input=self.len_series_i[:n_faults + 1], taps=[0, 1]),</span>
    <span class="c1">#         #                dict(input=self.len_series_f[:n_faults+1], taps=[0, 1]),</span>
    <span class="c1">#         #                dict(input=self.n_formations_per_serie[:n_faults+1], taps=[0, 1]),</span>
    <span class="c1">#         #                dict(input=self.u_grade_T[:n_faults + 1], taps=[0])]</span>
    <span class="c1">#         #     )</span>
    <span class="c1">#</span>
    <span class="c1">#         fault_matrix = fault_loop[0]</span>
    <span class="c1">#         pfai_fault = fault_loop[1]</span>
    <span class="c1">#         if n_faults == 1:</span>
    <span class="c1">#             self.fault_matrix = fault_matrix[0]</span>
    <span class="c1">#         if n_faults &gt; 1:</span>
    <span class="c1">#             self.fault_matrix = fault_matrix[-1, 0]</span>
    <span class="c1">#</span>
    <span class="c1">#         if &#39;faults block&#39; in self.verbose:</span>
    <span class="c1">#             self.fault_matrix = theano.printing.Print(&#39;I am outside the faults&#39;)(fault_matrix[-1])</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         pfai_fault = T.vector()</span>
    <span class="c1">#    # self.u_grade_T = theano.printing.Print(&#39;drift degree&#39;)(self.u_grade_T)</span>
    <span class="c1">#    # self.a_T = theano.printing.Print(&#39;range&#39;)(self.a_T)</span>
    <span class="c1">#     self.compute_all = compute_all</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#     # Checking there are more potential fields in the data that the faults.</span>
    <span class="c1">#     if len(self.len_series_f.get_value())-1 &gt; n_faults:</span>
    <span class="c1">#         if self.compute_all:</span>
    <span class="c1">#             final_block_init = T.vertical_stack(self.final_block, self.final_block)#, self.final_block)</span>
    <span class="c1">#             # Loop the series to create the Final block</span>
    <span class="c1">#             loop_results, updates2 = theano.scan(</span>
    <span class="c1">#                 fn=self.compute_a_series,</span>
    <span class="c1">#                 outputs_info=[final_block_init, None],</span>
    <span class="c1">#                 sequences=[dict(input=self.len_series_i[n_faults:], taps=[0, 1]),</span>
    <span class="c1">#                            dict(input=self.len_series_f[n_faults:], taps=[0, 1]),</span>
    <span class="c1">#                            dict(input=self.n_formations_per_serie[n_faults:], taps=[0, 1]),</span>
    <span class="c1">#                            dict(input=self.u_grade_T[n_faults:], taps=[0])]</span>
    <span class="c1">#             )</span>
    <span class="c1">#</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             # Loop the series to create the Final block</span>
    <span class="c1">#             loop_results, updates2 = theano.scan(</span>
    <span class="c1">#                 fn=self.compute_a_series,</span>
    <span class="c1">#                 outputs_info=[final_block_init, None],</span>
    <span class="c1">#                 sequences=[dict(input=self.len_series_i[n_faults:], taps=[0, 1]),</span>
    <span class="c1">#                            dict(input=self.len_series_f[n_faults:], taps=[0, 1]),</span>
    <span class="c1">#                            dict(input=self.n_formations_per_serie[n_faults:], taps=[0, 1]),</span>
    <span class="c1">#                            dict(input=self.u_grade_T[n_faults:], taps=[0])]</span>
    <span class="c1">#             )</span>
    <span class="c1">#</span>
    <span class="c1">#         all_series = loop_results[0]</span>
    <span class="c1">#         pfai_for = loop_results[1]</span>
    <span class="c1">#         if n_faults == 0:</span>
    <span class="c1">#             pfai = pfai_for</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             pfai = T.vertical_stack(pfai_fault, pfai_for)</span>
    <span class="c1">#           #  all_series = T.stack((fault_matrix[:, :-2 * self.len_points], all_series), axis=0)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         # We just pass the faults block</span>
    <span class="c1">#         all_series = fault_matrix[:, :-2 * self.len_points]</span>
    <span class="c1">#         pfai = pfai_fault</span>
    <span class="c1">#</span>
    <span class="c1">#    # pfai = T.vertical_stack(pfai_fault, pfai_for)</span>
    <span class="c1">#     #self.pot_value.set_value(self.final_potential_field_at_interfaces)</span>
    <span class="c1">#     return all_series, pfai</span>

    <span class="k">def</span> <span class="nf">compute_geological_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_faults</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">compute_all</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Init all</span>
        <span class="k">if</span> <span class="n">compute_all</span><span class="p">:</span>
            <span class="c1"># Change the flag to extend the graph in the compute fault and compute series function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_all</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Init faults block. Here we store the block and potential field results</span>
            <span class="n">fault_block_init</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
            <span class="n">fault_block_init</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;final block of faults init&#39;</span>
            <span class="n">fault_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
            <span class="c1"># Here we store the value of the potential field at interfaces</span>
            <span class="c1">#pfai_fault = T.zeros((0, len(self.len_series_f.get_value())))</span>
            <span class="n">pfai_fault</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># Init lithology block. Here we store the block and potential field results</span>
            <span class="n">lith_block_init</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
            <span class="n">lith_block_init</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;final block of lithologies init&#39;</span>
            <span class="n">lith_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
            <span class="c1">#pfai_lith = T.zeros((0, len(self.len_series_f.get_value()) ))</span>
            <span class="n">pfai_lith</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Change the flag to extend the graph in the compute fault and compute series function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_all</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Init faults block. Here we store the block and potential field results</span>
            <span class="n">fault_block_init</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
            <span class="n">fault_block_init</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;final block of faults init&#39;</span>
            <span class="n">fault_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
            <span class="c1"># Here we store the value of the potential field at interfaces</span>
           <span class="c1"># pfai_fault = T.zeros((0, len(self.len_series_f.get_value())))</span>
            <span class="n">pfai_fault</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># Init lithology block. Here we store the block and potential field results</span>
            <span class="n">lith_block_init</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
            <span class="n">lith_block_init</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;final block of lithologies init&#39;</span>
            <span class="n">lith_matrix</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">))</span>
           <span class="c1"># pfai_lith = T.zeros((0, len(self.len_series_f.get_value()) ))</span>
            <span class="n">pfai_lith</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Compute Faults</span>
        <span class="k">if</span> <span class="n">n_faults</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># --DEP--? Initialize yet simulated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yet_simulated</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">fault_block_init</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Looping</span>
            <span class="n">fault_loop</span><span class="p">,</span> <span class="n">updates3</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
                <span class="n">fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_a_fault</span><span class="p">,</span>
                <span class="n">outputs_info</span><span class="o">=</span><span class="p">[</span><span class="n">fault_block_init</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>  <span class="c1"># This line may be used for the faults network</span>
                <span class="n">sequences</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">len_series_i</span><span class="p">[:</span><span class="n">n_faults</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                           <span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">len_series_f</span><span class="p">[:</span><span class="n">n_faults</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                           <span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="p">[:</span><span class="n">n_faults</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                           <span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T</span><span class="p">[:</span><span class="n">n_faults</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="p">)</span>

            <span class="n">fault_matrix</span> <span class="o">=</span> <span class="n">fault_loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pfai_fault</span> <span class="o">=</span> <span class="n">fault_loop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># pfai_fault = T.set_subtensor(pfai_fault[0, 0], pfai_fault[0, 0] + pfai_fault[0, 0] * 0.001)</span>
            <span class="c1"># pfai_fault = T.set_subtensor(pfai_fault[-1, -1], pfai_fault[-1, -1] - pfai_fault[0, 0] * 0.001)</span>

            <span class="c1"># Add the drift function</span>
            <span class="k">if</span> <span class="n">n_faults</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span> <span class="o">=</span> <span class="n">fault_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n_faults</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fault_matrix</span> <span class="o">=</span> <span class="n">fault_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check if there are lithologies to compute</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len_series_f</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">n_faults</span><span class="p">:</span>
             <span class="c1"># Compute Lithologies</span>
             <span class="n">lith_loop</span><span class="p">,</span> <span class="n">updates2</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
                 <span class="n">fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_a_series</span><span class="p">,</span>
                 <span class="n">outputs_info</span><span class="o">=</span><span class="p">[</span><span class="n">lith_block_init</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                 <span class="n">sequences</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">len_series_i</span><span class="p">[</span><span class="n">n_faults</span><span class="p">:],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                            <span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">len_series_f</span><span class="p">[</span><span class="n">n_faults</span><span class="p">:],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                            <span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="p">[</span><span class="n">n_faults</span><span class="p">:],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                            <span class="nb">dict</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">u_grade_T</span><span class="p">[</span><span class="n">n_faults</span><span class="p">:],</span> <span class="n">taps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
             <span class="p">)</span>

             <span class="n">lith_matrix</span> <span class="o">=</span> <span class="n">lith_loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
             <span class="n">pfai_lith</span> <span class="o">=</span> <span class="n">lith_loop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Now we have to stack the potential fields at interfaces, but before we need to add a small margin to the</span>
        <span class="c1"># extremes to correct float32 errors for the marchig cubes later on</span>
        <span class="c1"># pfai_lith = T.set_subtensor(pfai_lith[0, 0], pfai_lith[0, 0] + pfai_lith[0, 0] * 0.001)</span>
        <span class="c1"># pfai_lith = T.set_subtensor(pfai_lith[-1, -1], pfai_lith[-1, -1] - pfai_lith[0, 0] * 0.001)</span>

        <span class="c1"># pfai_lith = T.set_subtensor(pfai_lith[0], pfai_lith[0] + pfai_lith[0] * 0.001)</span>
        <span class="c1"># pfai_lith = T.set_subtensor(pfai_lith[-1], pfai_lith[-1] - pfai_lith[0] * 0.001)</span>

        <span class="n">pfai</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">vertical_stack</span><span class="p">(</span><span class="n">pfai_fault</span><span class="p">,</span> <span class="n">pfai_lith</span><span class="p">)</span>
        <span class="c1"># if n_faults == 0:</span>
        <span class="c1">#     pfai = pfai_lith</span>
        <span class="c1">#     sol_block = lith_matrix</span>
        <span class="c1">#</span>
        <span class="c1"># else:</span>
        <span class="c1">#</span>
        <span class="c1">#     sol_block = T.stack((fault_matrix, lith_matrix), axis=0)</span>
        <span class="c1"># if n_faults != 0 and len(self.len_series_f.get_value()) - 1 &gt; n_faults:</span>
        <span class="c1">#     return lith_matrix[-1, :, :-2 * self.len_points], fault_matrix[-1, :, :-2 * self.len_points], pfai</span>
        <span class="c1"># if n_faults == 0 and len(self.len_series_f.get_value()) - 1 &gt; n_faults:</span>
        <span class="c1">#     return lith_matrix[-1, :, :-2 * self.len_points], None, pfai</span>
        <span class="c1"># if n_faults != 0 and not len(self.len_series_f.get_value()) - 1 &gt; n_faults:</span>
        <span class="c1">#     return None, fault_matrix[-1, :, :-2 * self.len_points], pfai</span>

        <span class="k">return</span> <span class="n">lith_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">],</span> <span class="n">fault_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_points</span><span class="p">],</span> <span class="n">pfai</span></div>

    <span class="c1"># ==================================</span>
    <span class="c1"># Geophysics</span>
    <span class="c1"># ==================================</span>
    <span class="c1">#</span>


    <span class="c1"># def slice_cells(self, selected_cells, block_lith):</span>
    <span class="c1">#</span>
    <span class="c1">#     # First change the bedrock to arbitrary value</span>
    <span class="c1">#     new_block = block-lith + 1</span>
    <span class="c1">#</span>
    <span class="c1">#     (new_block * selected_cells[:. T.newaxis?]).nonzero_values()</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def set_densities(self, block_lith):</span>
    <span class="c1">#</span>
    <span class="c1">#     def switch_densities(lith, block):</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#         Args:</span>
    <span class="c1">#             lith:</span>
    <span class="c1">#             block:</span>
    <span class="c1">#</span>
    <span class="c1">#         Returns:</span>
    <span class="c1">#</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         densities = T.switch(</span>
    <span class="c1">#             T.eq(sed_dips_dips, 0),  # This is the condition</span>
    <span class="c1">#             0,  # If true it is equal to 0. This is how a direction affect another</span>
    <span class="c1">#             (  # else, following Chiles book</span>
    <span class="c1">#</span>
    <span class="c1">#         return</span>
    <span class="c1">#</span>
    <span class="c1">#     partial_block, updates2 = theano.scan(</span>
    <span class="c1">#         fn=compare,</span>
    <span class="c1">#         outputs_info=None,</span>
    <span class="c1">#         sequences=[dict(input=self.n_formation)],</span>
    <span class="c1">#         non_sequences=block_lith)</span>

<span class="c1">#class ForwardGravity(TheanoGraph_pro):</span>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to GeMpys documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Kriging.html">Kriging structure of the <em>Potential field method</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code.html">Code</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Miguel de la Varga, CGR-Aachen Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>