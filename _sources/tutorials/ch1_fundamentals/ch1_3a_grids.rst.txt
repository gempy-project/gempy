
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/ch1_fundamentals/ch1_3a_grids.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_ch1_fundamentals_ch1_3a_grids.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_ch1_fundamentals_ch1_3a_grids.py:


1.3a: Grids.
============

.. GENERATED FROM PYTHON SOURCE LINES 6-16

.. code-block:: Python


    import numpy as np
    import matplotlib.pyplot as plt

    import gempy as gp
    from gempy.core.data import Grid
    from gempy.core.data.grid_modules import RegularGrid

    np.random.seed(55500)








.. GENERATED FROM PYTHON SOURCE LINES 17-24

The Grid Class
--------------

The Grid class interacts with the rest of the data classes and grid
subclasses. Its main purpose is to feed coordinates XYZ to the
interpolator.


.. GENERATED FROM PYTHON SOURCE LINES 26-28

.. code-block:: Python

    grid = Grid()








.. GENERATED FROM PYTHON SOURCE LINES 29-34

The most important attribute of Grid is ``values`` (and ``values_r``
which are the values rescaled) which are the 3D points in space that
kriging will be evaluated on. This array will be fed by "grid types" on
a **composition** relation with Grid:


.. GENERATED FROM PYTHON SOURCE LINES 36-38

.. image:: /_static/grids.jpg


.. GENERATED FROM PYTHON SOURCE LINES 40-42

.. code-block:: Python

    print(grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    []




.. GENERATED FROM PYTHON SOURCE LINES 43-47

At the moment of writing this tutorial, there are 5 grid types. The
number of grid types is scalable, and down the road we aim to connect
other grid packages (like `Discretize <https://pypi.org/project/discretize/>`_) as an extra Grid type.


.. GENERATED FROM PYTHON SOURCE LINES 49-50

This is an enum now

.. GENERATED FROM PYTHON SOURCE LINES 50-52

.. code-block:: Python

    print(grid.GridTypes)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <enum 'GridTypes'>




.. GENERATED FROM PYTHON SOURCE LINES 53-56

Each grid contains its own ``values`` attribute as well as other
methods to manipulate them depending on the type of grid.


.. GENERATED FROM PYTHON SOURCE LINES 58-60

.. code-block:: Python

    print(grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    []




.. GENERATED FROM PYTHON SOURCE LINES 61-64

We can see which grids are activated (i.e. they are going to be
interpolated and therefore will live on ``Grid().values``) by:


.. GENERATED FROM PYTHON SOURCE LINES 66-68

.. code-block:: Python

    print(grid.active_grids)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    GridTypes.NONE




.. GENERATED FROM PYTHON SOURCE LINES 69-72

By default, only the *regular grid* (``grid.regular_grid``) is active. However, since the regular
grid is still empty, ``Grid().values`` is empty too.


.. GENERATED FROM PYTHON SOURCE LINES 74-76

.. code-block:: Python

    print(grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    []




.. GENERATED FROM PYTHON SOURCE LINES 77-79

The last important attribute of Grid is the length:


.. GENERATED FROM PYTHON SOURCE LINES 81-83

.. code-block:: Python

    print(grid.length)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    []




.. GENERATED FROM PYTHON SOURCE LINES 84-90

Length gives back the interface indices between grids on the
``Grid().values`` attribute. This can be used after interpolation to
know which interpolated values and coordinates correspond to each grid
type. You can use the method ``get_grid_args`` to return the indices by
name:


.. GENERATED FROM PYTHON SOURCE LINES 92-94

.. code-block:: Python

    print(grid.topography)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    None




.. GENERATED FROM PYTHON SOURCE LINES 95-98

By now all is a bit confusing because we have no values. Let's start
adding values to the different grids:


.. GENERATED FROM PYTHON SOURCE LINES 100-106

Regular Grid
~~~~~~~~~~~~

The ``Grid`` class has a bunch of methods to set each grid type and
activate them.


.. GENERATED FROM PYTHON SOURCE LINES 108-110

.. code-block:: Python

    help(RegularGrid)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Help on class RegularGrid in module gempy.core.data.grid_modules.grid_types:

    class RegularGrid(builtins.object)
     |  RegularGrid(extent: numpy.ndarray, resolution: numpy.ndarray, transform: Optional[gempy_engine.core.data.transforms.Transform] = None)
     |  
     |  Class with the methods and properties to manage 3D regular grids where the model will be interpolated.
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, extent: numpy.ndarray, resolution: numpy.ndarray, transform: Optional[gempy_engine.core.data.transforms.Transform] = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  get_values_vtk_format(self, orthogonal: bool = False) -> numpy.ndarray
     |  
     |  set_regular_grid(self, extent: Sequence[float], resolution: Sequence[int], transform: Optional[gempy_engine.core.data.transforms.Transform] = None)
     |      Set a regular grid into the values parameters for further computations
     |      Args:
     |          extent (list, np.ndarry):  [x_min, x_max, y_min, y_max, z_min, z_max]
     |          resolution (list, np.ndarray): [nx, ny, nz]
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_corners_box(pivot: tuple, point_x_axis: tuple, distance_point3: float, zmin: float, zmax: float, resolution: numpy.ndarray, plot: bool = True) from builtins.type
     |      Always rotate around the z axis towards the positive x axis. 
     |      The distance_point3 is the distance from the pivot to the point3.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  plot_rotation(regular_grid, pivot, point_x_axis, point_y_axis)
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  bounding_box
     |  
     |  dx
     |  
     |  dx_dy_dz
     |  
     |  dy
     |  
     |  dz
     |  
     |  values_vtk_format
     |  
     |  x_coord
     |  
     |  y_coord
     |  
     |  z_coord
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  transform
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'_transform': <class 'gempy_engine.core.data.transf...
     |  
     |  __dataclass_fields__ = {'_transform': Field(name='_transform',type=<cl...
     |  
     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...
     |  
     |  __hash__ = None
     |  
     |  __match_args__ = ('resolution', 'extent', 'values', 'mask_topo', '_tra...





.. GENERATED FROM PYTHON SOURCE LINES 111-116

.. code-block:: Python

    extent = np.array([0, 100, 0, 100, -100, 0])
    resolution = np.array([20, 20, 20])
    grid.dense_grid = RegularGrid(extent, resolution)
    print(grid.regular_grid)  # RegularGrid will return either dense grid or octree grid depending on what is set





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    RegularGrid(resolution=array([20, 20, 20]), extent=array([   0.,  100.,    0.,  100., -100.,    0.]), values=array([[  2.5,   2.5, -97.5],
           [  2.5,   2.5, -92.5],
           [  2.5,   2.5, -87.5],
           ...,
           [ 97.5,  97.5, -12.5],
           [ 97.5,  97.5,  -7.5],
           [ 97.5,  97.5,  -2.5]]), mask_topo=array([], shape=(0, 3), dtype=bool), _transform=None)




.. GENERATED FROM PYTHON SOURCE LINES 117-119

Now the regular grid object composed in ``Grid`` has been filled:


.. GENERATED FROM PYTHON SOURCE LINES 121-123

.. code-block:: Python

    print(grid.regular_grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[  2.5   2.5 -97.5]
     [  2.5   2.5 -92.5]
     [  2.5   2.5 -87.5]
     ...
     [ 97.5  97.5 -12.5]
     [ 97.5  97.5  -7.5]
     [ 97.5  97.5  -2.5]]




.. GENERATED FROM PYTHON SOURCE LINES 124-127

And the regular grid has been set active (it was already active in any
case):


.. GENERATED FROM PYTHON SOURCE LINES 129-131

.. code-block:: Python

    print(grid.active_grids)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    GridTypes.NONE|DENSE




.. GENERATED FROM PYTHON SOURCE LINES 132-134

Therefore, the grid values will be equal to the regular grid:


.. GENERATED FROM PYTHON SOURCE LINES 136-138

.. code-block:: Python

    print(grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[  2.5   2.5 -97.5]
     [  2.5   2.5 -92.5]
     [  2.5   2.5 -87.5]
     ...
     [ 97.5  97.5 -12.5]
     [ 97.5  97.5  -7.5]
     [ 97.5  97.5  -2.5]]




.. GENERATED FROM PYTHON SOURCE LINES 139-141

And the indices to extract the different arrays:


.. GENERATED FROM PYTHON SOURCE LINES 143-145

.. code-block:: Python

    print(grid.length)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    []




.. GENERATED FROM PYTHON SOURCE LINES 146-151

Custom Grid
~~~~~~~~~~~

Completely free XYZ values.


.. GENERATED FROM PYTHON SOURCE LINES 153-155

.. code-block:: Python

    gp.set_custom_grid(grid, np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Active grids: GridTypes.NONE|CUSTOM|DENSE

    <gempy.core.data.grid_modules.grid_types.CustomGrid object at 0x7f87dbcac040>



.. GENERATED FROM PYTHON SOURCE LINES 156-159

Again, ``set_any_grid`` will create a grid and activate it. So now the
composed object will contain values:


.. GENERATED FROM PYTHON SOURCE LINES 161-163

.. code-block:: Python

    print(grid.custom_grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[1 2 3]
     [4 5 6]
     [7 8 9]]




.. GENERATED FROM PYTHON SOURCE LINES 164-166

And since it is active, it will be added to the grid.values stack:


.. GENERATED FROM PYTHON SOURCE LINES 168-170

.. code-block:: Python

    print(grid.active_grids)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    GridTypes.NONE|CUSTOM|DENSE




.. GENERATED FROM PYTHON SOURCE LINES 171-173

.. code-block:: Python

    print(grid.values.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (8003, 3)




.. GENERATED FROM PYTHON SOURCE LINES 174-177

We can still recover those values with ``get_grid`` or by getting the
slicing args:


.. GENERATED FROM PYTHON SOURCE LINES 179-181

.. code-block:: Python

    print(grid.custom_grid)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <gempy.core.data.grid_modules.grid_types.CustomGrid object at 0x7f87dbcac040>




.. GENERATED FROM PYTHON SOURCE LINES 182-184

.. code-block:: Python

    print(grid.custom_grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[1 2 3]
     [4 5 6]
     [7 8 9]]




.. GENERATED FROM PYTHON SOURCE LINES 185-192

Topography
~~~~~~~~~~

Now we can set the topography. :class:`Topography <gempy.core.grid_modules.topography.Topography>`
contains methods to create manual topographies as well as using gdal for
dealing with raster data. By default, we will create a random topography:


.. GENERATED FROM PYTHON SOURCE LINES 194-196

.. code-block:: Python

    gp.set_topography_from_random(grid)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [-20.   0.]
    Active grids: GridTypes.NONE|TOPOGRAPHY|CUSTOM|DENSE

    <gempy.core.data.grid_modules.topography.Topography object at 0x7f881e5cc8b0>



.. GENERATED FROM PYTHON SOURCE LINES 197-199

.. code-block:: Python

    print(grid.active_grids)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    GridTypes.NONE|TOPOGRAPHY|CUSTOM|DENSE




.. GENERATED FROM PYTHON SOURCE LINES 200-202

Now the grid values will contain both the regular grid and topography:


.. GENERATED FROM PYTHON SOURCE LINES 204-206

.. code-block:: Python

    print(grid.values, grid.length)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[  2.5          2.5        -97.5       ]
     [  2.5          2.5        -92.5       ]
     [  2.5          2.5        -87.5       ]
     ...
     [100.          89.47368421 -14.13839552]
     [100.          94.73684211 -16.12793911]
     [100.         100.         -16.21462612]] []




.. GENERATED FROM PYTHON SOURCE LINES 207-209

.. code-block:: Python

    print(grid.topography.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[  0.           0.         -14.23224119]
     [  0.           5.26315789 -14.18893341]
     [  0.          10.52631579 -13.54018217]
     ...
     [100.          89.47368421 -14.13839552]
     [100.          94.73684211 -16.12793911]
     [100.         100.         -16.21462612]]




.. GENERATED FROM PYTHON SOURCE LINES 210-212

We can compare it to the topography.values:


.. GENERATED FROM PYTHON SOURCE LINES 214-216

.. code-block:: Python

    print(grid.topography.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[  0.           0.         -14.23224119]
     [  0.           5.26315789 -14.18893341]
     [  0.          10.52631579 -13.54018217]
     ...
     [100.          89.47368421 -14.13839552]
     [100.          94.73684211 -16.12793911]
     [100.         100.         -16.21462612]]




.. GENERATED FROM PYTHON SOURCE LINES 217-220

Now that we have more than one grid, we can activate and deactivate any
of them in real time:


.. GENERATED FROM PYTHON SOURCE LINES 222-225

.. code-block:: Python

    grid.active_grids ^= grid.GridTypes.TOPOGRAPHY
    grid.active_grids ^= grid.GridTypes.DENSE








.. GENERATED FROM PYTHON SOURCE LINES 226-228

Since now all grids are deactivated, the values will be empty:


.. GENERATED FROM PYTHON SOURCE LINES 230-232

.. code-block:: Python

    print(grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[1 2 3]
     [4 5 6]
     [7 8 9]]




.. GENERATED FROM PYTHON SOURCE LINES 233-235

.. code-block:: Python

    grid.active_grids |= grid.GridTypes.TOPOGRAPHY








.. GENERATED FROM PYTHON SOURCE LINES 236-238

.. code-block:: Python

    print(grid.values, grid.values.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[  1.           2.           3.        ]
     [  4.           5.           6.        ]
     [  7.           8.           9.        ]
     ...
     [100.          89.47368421 -14.13839552]
     [100.          94.73684211 -16.12793911]
     [100.         100.         -16.21462612]] (403, 3)




.. GENERATED FROM PYTHON SOURCE LINES 239-241

.. code-block:: Python

    grid.active_grids |= grid.GridTypes.DENSE








.. GENERATED FROM PYTHON SOURCE LINES 242-244

.. code-block:: Python

    print(grid.values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[  2.5          2.5        -97.5       ]
     [  2.5          2.5        -92.5       ]
     [  2.5          2.5        -87.5       ]
     ...
     [100.          89.47368421 -14.13839552]
     [100.          94.73684211 -16.12793911]
     [100.         100.         -16.21462612]]




.. GENERATED FROM PYTHON SOURCE LINES 245-254

Centered Grid
~~~~~~~~~~~~~

This grid contains an irregular grid where the majority of voxels are
centered around a value (or values). This type of grid is usually used
to compute certain types of forward physics where the influence
decreases with distance (e.g. gravity: Check `tutorial 2.2-Cell-selection <https://github.com/cgre-aachen/gempy/blob/master/examples/tutorials/ch2-Geophysics/ch2_2_cell_selection.py>`_
)


.. GENERATED FROM PYTHON SOURCE LINES 256-263

.. code-block:: Python

    gp.set_centered_grid(
        grid,
        centers=np.array([[300, 0, 0], [0, 0, 0]]),
        resolution=[10, 10, 20],
        radius=np.array([100, 100, 100])
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Active grids: GridTypes.NONE|CENTERED|TOPOGRAPHY|CUSTOM|DENSE

    CenteredGrid(centers=array([[300,   0,   0],
           [  0,   0,   0]]), resolution=[10, 10, 20], radius=array([100, 100, 100]), kernel_grid_centers=array([[-100.        , -100.        ,   -6.        ],
           [-100.        , -100.        ,   -7.2       ],
           [-100.        , -100.        ,   -7.52912998],
           ...,
           [ 100.        ,  100.        ,  -79.90178533],
           [ 100.        ,  100.        , -100.17119644],
           [ 100.        ,  100.        , -126.        ]]), left_voxel_edges=array([[ 34.1886117 ,  34.1886117 ,  -0.6       ],
           [ 34.1886117 ,  34.1886117 ,  -0.6       ],
           [ 34.1886117 ,  34.1886117 ,  -0.16456499],
           ...,
           [ 34.1886117 ,  34.1886117 ,  -7.95331123],
           [ 34.1886117 ,  34.1886117 , -10.13470556],
           [ 34.1886117 ,  34.1886117 , -12.91440178]]), right_voxel_edges=array([[ 34.1886117 ,  34.1886117 ,  -0.6       ],
           [ 34.1886117 ,  34.1886117 ,  -0.16456499],
           [ 34.1886117 ,  34.1886117 ,  -0.20970105],
           ...,
           [ 34.1886117 ,  34.1886117 , -10.13470556],
           [ 34.1886117 ,  34.1886117 , -12.91440178],
           [ 34.1886117 ,  34.1886117 , -12.91440178]]))



.. GENERATED FROM PYTHON SOURCE LINES 264-268

Resolution and radius create a geometrically spaced kernel (blue dots) which
will be used to create a grid around each of the center points (red
dots):


.. GENERATED FROM PYTHON SOURCE LINES 270-299

.. code-block:: Python


    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    ax.scatter(
        grid.centered_grid.values[:, 0],
        grid.centered_grid.values[:, 1],
        grid.centered_grid.values[:, 2],
        '.',
        alpha=.2
    )

    ax.scatter(
        np.array([[300, 0, 0], [0, 0, 0]])[:, 0],
        np.array([[300, 0, 0], [0, 0, 0]])[:, 1],
        np.array([[300, 0, 0], [0, 0, 0]])[:, 2],
        c='r',
        alpha=1,
        s=30
    )

    ax.set_xlim(-100, 400)
    ax.set_ylim(-100, 100)
    ax.set_zlim(-120, 0)
    ax.set_xlabel('X Label')
    ax.set_ylabel('Y Label')
    ax.set_zlabel('Z Label')
    plt.show()




.. image-sg:: /tutorials/ch1_fundamentals/images/sphx_glr_ch1_3a_grids_001.png
   :alt: ch1 3a grids
   :srcset: /tutorials/ch1_fundamentals/images/sphx_glr_ch1_3a_grids_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 300-305

Section Grid
~~~~~~~~~~~~

This grid type has its own tutorial. See :doc:`ch1_3b_cross_sections`



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.083 seconds)


.. _sphx_glr_download_tutorials_ch1_fundamentals_ch1_3a_grids.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: ch1_3a_grids.ipynb <ch1_3a_grids.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: ch1_3a_grids.py <ch1_3a_grids.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
